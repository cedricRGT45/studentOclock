#!/usr/bin/env node
import B from "yargs";
import { hideBin as _ } from "yargs/helpers";
import p from "node:path";
import L from "prettier";
import { Project as j, StructureKind as Q, SyntaxKind as s, ScriptTarget as V } from "ts-morph";
import g from "node:fs";
import b from "inquirer";
import m from "chalk";
import q from "latest-version";
const W = (e) => {
  const r = new j().createSourceFile("test.spec.ts", {
    statements: [
      {
        kind: Q.ImportDeclaration,
        moduleSpecifier: "vitest",
        namedImports: [
          "vi",
          "describe",
          "it",
          "expect",
          "afterAll",
          "vitest",
          "afterEach"
          // "beforeAll",
        ]
      },
      // TODO: Later feature
      // Difficult right now because of node module resolution
      // {
      //   kind: StructureKind.ImportDeclaration,
      //   moduleSpecifier: `./${payload.fileName.replace(/\.tsx?$/, "")}`,
      //   namedImports: [...payload.exports],
      // },
      `
`,
      ...e.imports.map(
        (t) => `vi.mock("${t.packageName}", () => (${JSON.stringify(
          Y(t, e.propertyAccess),
          null,
          4
        ).replace(/["']/g, "")}));`
      ),
      `
`,
      e.exports.length > 1 ? `describe("my-awesome-tests", () => {
    afterAll(() => {
      vi.resetAllMocks();
    });

    afterEach(() => {
      vi.clearAllMocks();
    });

    ${e.exports.map(
        (t) => `describe("${t}", () => {
      it("should work", async () => {
        ${e.localMocks.namedImportMocks.map(v).join(`
`)}
        ${e.localMocks.defaultMocks.map(S).join(`
`)}

        expect(true).toEqual(true);
      });
    });`
      ).join(`

`)}
})` : e.exports.map(
        (t) => `describe("${t}", () => {
    afterAll(() => {
      vi.resetAllMocks();
    });

    afterEach(() => {
      vi.clearAllMocks();
    });

    it("should work", async () => {
      ${e.localMocks.namedImportMocks.map(v).join(`
`)}
      ${e.localMocks.defaultMocks.map(S).join(`
`)}

      expect(true).toEqual(true);
    });
  });`
      ).join(`

`)
    ]
  });
  return r.formatText({}), r;
}, Y = (e, o) => ({
  default: e.defaultImports.length > 0 ? O(e.defaultImports, o) : void 0,
  ...O(e.namespaceImports, o),
  ...e.namedImports.length > 0 ? e.namedImports.reduce(
    (t, n) => ({
      ...t,
      [n]: "vi.fn()"
    }),
    {}
  ) : {}
}), O = (e, o) => e.map((r) => o[r] ? Array.from(o[r]) : []).flat().reduce(
  (r, t) => ({
    ...r,
    [t]: "vi.fn()"
  }),
  {}
), v = (e) => `vi.spyOn(await import("${e.packageName}"), "${e.property}").mockReturnValue(undefined);`, S = (e) => `vi.spyOn((await import("${e.packageName}")).default, "${e.property}").mockReturnValue(undefined);`, G = async (e) => {
  const o = W(e);
  return await L.format(o.getFullText(), {
    semi: !0,
    trailingComma: "all",
    parser: "babel"
  });
}, R = "1.1.0", z = (e, o) => {
  const r = e.getChildrenOfKind(s.StringLiteral)[0].getText().replace(/['"]+/g, ""), t = e.getChildrenOfKind(s.ImportClause)[0];
  let n = o;
  if (t === void 0)
    n = {
      ...n,
      imports: [
        ...n.imports,
        {
          type: "none",
          packageName: r
        }
      ]
    };
  else if (t.getChildrenOfKind(s.NamedImports).length > 0 && t.getChildrenOfKind(s.Identifier).length > 0) {
    const a = k(t), l = C(t);
    n = {
      ...n,
      imports: [
        ...n.imports,
        {
          type: "default-and-named",
          packageName: r,
          defaultImport: a,
          namedImports: l
        }
      ]
    };
  } else if (t.getChildrenOfKind(s.NamespaceImport).length > 0 && t.getChildrenOfKind(s.Identifier).length > 0) {
    const a = k(t), l = K(t);
    n = {
      ...n,
      imports: [
        ...n.imports,
        {
          type: "default-and-namespace",
          packageName: r,
          defaultImport: a,
          namespaceImport: l
        }
      ]
    };
  } else if (t.getChildrenOfKind(s.NamedImports).length > 0)
    n = {
      ...n,
      imports: [
        ...n.imports,
        {
          type: "named",
          packageName: r,
          namedImports: C(t)
        }
      ]
    };
  else if (t.getChildrenOfKind(s.NamespaceImport).length > 0) {
    const a = K(t);
    n = {
      ...n,
      imports: [
        ...n.imports,
        {
          type: "namespace",
          packageName: r,
          namespaceImport: a
        }
      ]
    };
  } else {
    const a = k(t);
    n = {
      ...n,
      imports: [
        ...n.imports,
        {
          type: "default",
          packageName: r,
          defaultImport: a
        }
      ]
    };
  }
  return n;
}, k = (e) => e.getChildrenOfKind(
  s.Identifier
)[0].getText(), C = (e) => e.getChildrenOfKind(
  s.NamedImports
)[0].getChildrenOfKind(s.SyntaxList)[0].getChildrenOfKind(
  s.ImportSpecifier
).map(
  (n) => n.getChildrenOfKind(s.Identifier)[0].getText()
), K = (e) => e.getChildrenOfKind(
  s.NamespaceImport
)[0].getChildrenOfKind(s.Identifier)[0].getText(), P = (e, o) => {
  const [r, t] = e.getChildrenOfKind(s.Identifier);
  return t === void 0 ? o : {
    ...o,
    propertyAccess: {
      ...o.propertyAccess,
      [r.getText()]: /* @__PURE__ */ new Set([
        ...o.propertyAccess[r.getText()] ?? [],
        t.getText()
      ])
    }
  };
}, Z = (e, o) => {
  const [r] = e.getChildrenOfKind(s.SyntaxList)[0]?.getChildrenOfKind(s.ExportKeyword) ?? [];
  if (!r || r.getText() !== "export")
    return o;
  const t = e.getFirstChildByKindOrThrow(s.VariableDeclarationList).getFirstChildByKindOrThrow(s.SyntaxList).getChildrenOfKind(s.VariableDeclaration).map((n) => n.getFirstChildByKindOrThrow(s.Identifier)).map((n) => n.getText());
  return {
    ...o,
    exports: [...o.exports, ...t]
  };
}, H = (e, o) => {
  const r = e.getChildrenOfKind(s.Identifier);
  if (r.length === 0)
    return o;
  const t = r[r.length - 1];
  return {
    ...o,
    exports: [...o.exports, t.getText()]
  };
}, M = (e, o) => {
  switch (e.getKind()) {
    case s.PropertyAccessExpression:
      o = P(e, o);
      break;
    case s.VariableStatement:
      o = Z(e, o);
      break;
    case s.ImportDeclaration:
      o = z(e, o);
      break;
    case s.ExportSpecifier:
      o = H(e, o);
      break;
  }
  for (const r of e.getChildren())
    o = M(r, o);
  return o;
}, J = (e) => e.reduce(
  (r, t) => {
    const n = r.find(
      (l) => l.packageName === t.packageName
    ), a = {
      packageName: t.packageName,
      defaultImports: [
        ...n ? n.defaultImports : [],
        ...t.type === "default" || t.type === "default-and-named" || t.type === "default-and-namespace" ? [t.defaultImport] : []
      ],
      namespaceImports: [
        ...n ? n.namespaceImports : [],
        ...t.type === "namespace" || t.type === "default-and-namespace" ? [t.namespaceImport] : []
      ],
      namedImports: [
        ...n ? n.namedImports : [],
        ...t.type === "named" || t.type === "default-and-named" ? [...t.namedImports] : []
      ]
    };
    return [
      ...r.filter((l) => l.packageName !== t.packageName),
      a
    ];
  },
  []
), U = (e, o, r) => {
  const n = new j({
    compilerOptions: {
      target: V.ESNext
    }
  }).createSourceFile(e, o), a = M(n, {
    imports: [],
    propertyAccess: {},
    exports: []
  });
  return {
    ...a,
    fileName: p.basename(r),
    imports: J(a.imports)
  };
}, X = ({
  imports: e,
  propertyAccess: o
}) => e.map((r, t) => {
  const n = {
    type: "confirm",
    name: t.toString(),
    // index hack because inquirer doesn't support file path as name
    message: `Do you want to mock "${r.packageName}"? (If this package only has types, you can skip this)`,
    default: !0
  }, a = {
    type: "confirm",
    name: `${t.toString()}-local`,
    message: `Do you want to mock "${r.packageName}" locally for each test? (so you can modify it per test)`,
    default: !1,
    when: (c) => c[t.toString()] === !0
  }, l = r.namedImports.map(
    (c) => ({
      type: "confirm",
      name: `${t.toString()}-named_import:${c}`,
      message: `Do you want to locally mock "${c}" from "${r.packageName}"? (You can only mock functions. If this is not a function. Do not mock it!)`,
      default: !0,
      when: (d) => d[`${t.toString()}-local`] === !0
    })
  ), u = ee(
    r,
    o
  ), h = u.filter(
    (c) => !T(
      c,
      r,
      o
    )
  ).map(
    (c) => ({
      type: "confirm",
      name: `${t.toString()}-property:${c}`,
      message: `Do you want to locally mock "${c}" from "${r.packageName}"? (You can only mock functions. If this is not a function. Do not mock it!)`,
      default: !0,
      when: (d) => d[`${t.toString()}-local`] === !0
    })
  ), I = u.filter(
    (c) => T(c, r, o)
  ).map(
    (c) => ({
      type: "confirm",
      name: `${t.toString()}-default_property:${c}`,
      message: `Do you want to locally mock "${c}" from the default import "${r.packageName}"? (You can only mock functions. If this is not a function. Do not mock it!)`,
      default: !0,
      when: (d) => d[`${t.toString()}-local`] === !0
    })
  );
  return [
    n,
    a,
    ...l,
    ...h,
    ...I
  ];
}).flat(), T = (e, o, r) => {
  const t = o.defaultImports.filter(
    (n) => n === o.packageName
  )[0];
  return t ? r[t]?.has(e) : !1;
}, ee = (e, o) => {
  const r = e.defaultImports.map((n) => Array.from(o[n])).flat(), t = e.namespaceImports.map((n) => Array.from(o[n])).flat();
  return [...r, ...t];
}, x = (e) => {
  const o = p.join(process.cwd(), e), r = p.parse(o).name, t = p.extname(o);
  return {
    filePath: o,
    fileNameWithoutExtension: r,
    fileExtension: t
  };
}, y = (e, o) => {
  const { fileNameWithoutExtension: r, fileExtension: t } = x(e);
  return `${r}.${o}${t}`;
}, te = (e) => p.dirname(e).replace(process.cwd(), ""), A = (e) => {
  const o = p.dirname(e).replace(process.cwd(), "");
  return g.existsSync(
    p.join(process.cwd(), o, y(e, "spec"))
  ) || g.existsSync(
    p.join(process.cwd(), o, y(e, "test"))
  );
};
console.log(
  m.bgBlueBright.black.bold("                                      ")
);
console.log(
  m.bgBlueBright.black.bold("   🧪 Welcome to create vitest! 🏗️     ")
);
console.log(m.bgBlueBright.black("                      by Dolan        "));
console.log("");
console.log(
  m.green(
    "Generate a vitest test (spec) file for a TypeScript file with best practices. Scaffold the test and mock all imports"
  )
);
console.log(
  m.blue(
    'ℹ️ Note: Every so often, run "npm create vitest@latest" or "npx create-vitest@latest" to update to the latest version. 🍆 '
  )
);
try {
  console.log(
    m.blue(
      `ℹ️ Current version: ${R}. Latest version: ${await q(
        "create-vitest"
      )}.`
    )
  );
} catch {
}
console.log("");
console.log(
  m.bgWhite.bold("GitHub: https://github.com/dolanmiu/create-vitest")
);
console.log("");
const {
  _: [f]
} = B(_(process.argv)).argv;
f && (/^[a-zA-Z0-9-_/\\]+\.tsx?$/.test(f) || (console.log(m.red("The file name must end in .ts or .tsx")), process.exit(1)), g.existsSync(p.join(process.cwd(), f)) || (console.log(m.red("The file does not exist!")), process.exit(1)), A(f) && (console.log(
  m.red(
    "A test file already exists for this file! Please delete the existing test file and try again."
  )
), process.exit(1)));
const oe = [
  ...f ? [] : [
    {
      type: "input",
      name: "fileName",
      message: "What is the name of the file you want to test? (Relative to current directory)",
      validate: async (e) => e === "" ? "You must specify a file name!" : /^[.a-zA-Z0-9-_/\\]+\.tsx?$/.test(e) ? g.existsSync(p.join(process.cwd(), e)) ? A(e) ? "A test file already exists for this file!" : !0 : "The file does not exist!" : "The file name must end in .ts or .tsx"
    }
  ],
  {
    type: "list",
    name: "suffix",
    message: "What suffix would you like the test to end in?",
    choices: ["spec", "test"]
  },
  {
    type: "confirm",
    name: "confirm",
    message: (e) => `The path of the file is "${x(f ?? e.fileName).filePath}". Is this correct?`
  }
], re = async () => {
  const e = await b.prompt(oe);
  !f && !e.fileName && (console.log(m.red("You must specify a file name!")), process.exit(1));
  const { filePath: o } = x(f ?? e.fileName), r = y(
    f ?? e.fileName,
    e.suffix
  ), t = g.readFileSync(o, "utf-8"), n = U(
    r,
    t,
    f ?? e.fileName
  ), a = X(n), l = await b.prompt(a), u = Object.entries(l).map(([i, D]) => {
    const F = parseInt(i.split("-")[0]), E = n.imports[F], [, w] = i.split("-named_import:"), [, N] = i.split("-property:"), [, $] = i.split("-default_property:");
    return {
      packageName: E.packageName,
      value: D,
      type: w ?? N ? "named_import" : $ ? "default" : "root",
      property: w ?? N ?? $
    };
  }).filter(({ value: i }) => !!i), h = new Set(
    u.map(({ packageName: i }) => i)
  ), I = u.filter(({ property: i }) => !!i).filter(({ type: i }) => i === "named_import").map((i) => i), c = u.filter(({ property: i }) => !!i).filter(({ type: i }) => i === "default").map((i) => i);
  console.log(m.green(`Generating ${r}...`));
  const d = await G({
    ...n,
    imports: n.imports.filter(
      (i) => h.has(i.packageName)
    ),
    localMocks: {
      namedImportMocks: I,
      defaultMocks: c
    }
  });
  g.promises.writeFile(
    p.join(process.cwd(), te(o), r),
    d
  );
};
re();
//# sourceMappingURL=main.js.map
