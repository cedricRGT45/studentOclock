{"version":3,"file":"main.js","sources":["../src/core/create-vitest-ast.ts","../src/core/create-test.ts","../src/core/ast/handlers/handle-import.ts","../src/core/ast/handlers/handle-property-access-expression.ts","../src/core/ast/handlers/handle-variable-statement.ts","../src/core/ast/handlers/export-specifier.ts","../src/core/ast/router.ts","../src/core/import-aggregator.ts","../src/core/get-file-properties.ts","../src/create-package-questions.ts","../src/path-utils.ts","../src/main.ts"],"sourcesContent":["import { Project, Node, StructureKind } from \"ts-morph\";\r\n\r\nimport { AggregateImport, ParsePayload } from \"./ast/types/parse-payload\";\r\n\r\nexport type SpyOnMockConfig = {\r\n  readonly packageName: string;\r\n  readonly property: string;\r\n};\r\n\r\nexport type DeDupedParsePayload = Omit<ParsePayload, \"imports\"> & {\r\n  readonly imports: readonly AggregateImport[];\r\n  readonly fileName: string;\r\n  readonly localMocks: {\r\n    readonly namedImportMocks: readonly SpyOnMockConfig[];\r\n    readonly defaultMocks: readonly SpyOnMockConfig[];\r\n  };\r\n};\r\n\r\nexport const createVitestAst = (payload: DeDupedParsePayload): Node => {\r\n  const project = new Project();\r\n\r\n  const testSourceFile = project.createSourceFile(\"test.spec.ts\", {\r\n    statements: [\r\n      {\r\n        kind: StructureKind.ImportDeclaration,\r\n        moduleSpecifier: \"vitest\",\r\n        namedImports: [\r\n          \"vi\",\r\n          \"describe\",\r\n          \"it\",\r\n          \"expect\",\r\n          \"afterAll\",\r\n          \"vitest\",\r\n          \"afterEach\",\r\n          // \"beforeAll\",\r\n        ],\r\n      },\r\n      // TODO: Later feature\r\n      // Difficult right now because of node module resolution\r\n      // {\r\n      //   kind: StructureKind.ImportDeclaration,\r\n      //   moduleSpecifier: `./${payload.fileName.replace(/\\.tsx?$/, \"\")}`,\r\n      //   namedImports: [...payload.exports],\r\n      // },\r\n      \"\\n\",\r\n      ...payload.imports.map(\r\n        (i) =>\r\n          `vi.mock(\"${i.packageName}\", () => (${JSON.stringify(\r\n            createMockObject(i, payload.propertyAccess),\r\n            null,\r\n            4\r\n          ).replace(/[\"']/g, \"\")}));`\r\n      ),\r\n      \"\\n\",\r\n      payload.exports.length > 1\r\n        ? `describe(\"my-awesome-tests\", () => {\r\n    afterAll(() => {\r\n      vi.resetAllMocks();\r\n    });\r\n\r\n    afterEach(() => {\r\n      vi.clearAllMocks();\r\n    });\r\n\r\n    ${payload.exports\r\n      .map(\r\n        (e) => `describe(\"${e}\", () => {\r\n      it(\"should work\", async () => {\r\n        ${payload.localMocks.namedImportMocks.map(createSpyOnNamedImportMockObject).join(\"\\n\")}\r\n        ${payload.localMocks.defaultMocks.map(createSpyOnDefaultMockObject).join(\"\\n\")}\r\n\r\n        expect(true).toEqual(true);\r\n      });\r\n    });`\r\n      )\r\n      .join(\"\\n\\n\")}\r\n})`\r\n        : payload.exports\r\n            .map(\r\n              (e) => `describe(\"${e}\", () => {\r\n    afterAll(() => {\r\n      vi.resetAllMocks();\r\n    });\r\n\r\n    afterEach(() => {\r\n      vi.clearAllMocks();\r\n    });\r\n\r\n    it(\"should work\", async () => {\r\n      ${payload.localMocks.namedImportMocks.map(createSpyOnNamedImportMockObject).join(\"\\n\")}\r\n      ${payload.localMocks.defaultMocks.map(createSpyOnDefaultMockObject).join(\"\\n\")}\r\n\r\n      expect(true).toEqual(true);\r\n    });\r\n  });`\r\n            )\r\n            .join(\"\\n\\n\"),\r\n    ],\r\n  });\r\n\r\n  testSourceFile.formatText({});\r\n\r\n  return testSourceFile;\r\n};\r\n\r\nconst createMockObject = (\r\n  i: AggregateImport,\r\n  propertyAccess: Record<string, Set<string>>\r\n) => {\r\n  const mock = {\r\n    default:\r\n      i.defaultImports.length > 0\r\n        ? createImportObject(i.defaultImports, propertyAccess)\r\n        : undefined,\r\n    ...createImportObject(i.namespaceImports, propertyAccess),\r\n    ...(i.namedImports.length > 0\r\n      ? i.namedImports.reduce(\r\n          (acc, curr) => ({\r\n            ...acc,\r\n            [curr]: `vi.fn()`,\r\n          }),\r\n          {}\r\n        )\r\n      : {}),\r\n  };\r\n\r\n  return mock;\r\n};\r\n\r\nconst createImportObject = (\r\n  imports: readonly string[],\r\n  propertyAccess: Record<string, Set<string>>\r\n): Record<string, string> => {\r\n  return imports\r\n    .map((i) => {\r\n      if (propertyAccess[i]) {\r\n        return Array.from(propertyAccess[i]);\r\n      } else {\r\n        return [];\r\n      }\r\n    })\r\n    .flat()\r\n    .reduce(\r\n      (acc, curr) => ({\r\n        ...acc,\r\n        [curr]: `vi.fn()`,\r\n      }),\r\n      {}\r\n    );\r\n};\r\n\r\nconst createSpyOnNamedImportMockObject = (spyOnConfig: SpyOnMockConfig): string => {\r\n  return `vi.spyOn(await import(\"${spyOnConfig.packageName}\"), \"${spyOnConfig.property}\").mockReturnValue(undefined);`;\r\n};\r\n\r\nconst createSpyOnDefaultMockObject = (spyOnConfig: SpyOnMockConfig): string => {\r\n  return `vi.spyOn((await import(\"${spyOnConfig.packageName}\")).default, \"${spyOnConfig.property}\").mockReturnValue(undefined);`;\r\n};\r\n","import prettier from \"prettier\";\r\nimport { DeDupedParsePayload, createVitestAst } from \"./create-vitest-ast\";\r\n\r\nexport const createTest = async (\r\n  payload: DeDupedParsePayload\r\n): Promise<string> => {\r\n  const output = createVitestAst(payload);\r\n\r\n  const formattedOutput = await prettier.format(output.getFullText(), {\r\n    semi: true,\r\n    trailingComma: \"all\",\r\n    parser: \"babel\",\r\n  });\r\n\r\n  return formattedOutput;\r\n};\r\n","// Many different types of imports\n// https://stackoverflow.com/questions/45867553/es6-typescript-import-import-and-names-on-a-single-line\nimport { Node, SyntaxKind, ImportClause } from \"ts-morph\";\n\nimport { ParsePayload } from \"../types/parse-payload\";\n\nexport const handleImport = (\n  node: Node,\n  parsePayload: ParsePayload\n): ParsePayload => {\n  const packageName = node\n    .getChildrenOfKind(SyntaxKind.StringLiteral)[0]\n    .getText()\n    .replace(/['\"]+/g, \"\");\n  const importClause = node.getChildrenOfKind(SyntaxKind.ImportClause)[0];\n\n  let output = parsePayload;\n\n  if (importClause === undefined) {\n    // No import clause e.g. import \"prettier\";\n\n    output = {\n      ...output,\n      imports: [\n        ...output.imports,\n        {\n          type: \"none\",\n          packageName,\n        },\n      ],\n    };\n  } else if (\n    importClause.getChildrenOfKind(SyntaxKind.NamedImports).length > 0 &&\n    importClause.getChildrenOfKind(SyntaxKind.Identifier).length > 0\n  ) {\n    // Default and named imports e.g. import viDefault, { vi, describe, it, expect } from \"vitest\";\n\n    const defaultImport = getDefaultImportName(importClause);\n    const namedImports = getNamedImports(importClause);\n\n    output = {\n      ...output,\n      imports: [\n        ...output.imports,\n        {\n          type: \"default-and-named\",\n          packageName,\n          defaultImport,\n          namedImports,\n        },\n      ],\n    };\n  } else if (\n    importClause.getChildrenOfKind(SyntaxKind.NamespaceImport).length > 0 &&\n    importClause.getChildrenOfKind(SyntaxKind.Identifier).length > 0\n  ) {\n    // Default and namespace imports e.g. import viDefault, * as vi from \"vitest\";\n\n    const defaultImport = getDefaultImportName(importClause);\n    const namespaceImport = getNamespaceImport(importClause);\n\n    output = {\n      ...output,\n      imports: [\n        ...output.imports,\n        {\n          type: \"default-and-namespace\",\n          packageName,\n          defaultImport,\n          namespaceImport,\n        },\n      ],\n    };\n  } else if (\n    importClause.getChildrenOfKind(SyntaxKind.NamedImports).length > 0\n  ) {\n    // Named imports e.g. import { vi, describe, it, expect } from \"vitest\";\n\n    output = {\n      ...output,\n      imports: [\n        ...output.imports,\n        {\n          type: \"named\",\n          packageName,\n          namedImports: getNamedImports(importClause),\n        },\n      ],\n    };\n  } else if (\n    importClause.getChildrenOfKind(SyntaxKind.NamespaceImport).length > 0\n  ) {\n    // Namespace imports e.g. import * as prettier from \"prettier\";\n\n    const namespaceImport = getNamespaceImport(importClause);\n\n    output = {\n      ...output,\n      imports: [\n        ...output.imports,\n        {\n          type: \"namespace\",\n          packageName,\n          namespaceImport: namespaceImport,\n        },\n      ],\n    };\n  } else {\n    // Default imports e.g. import prettier from \"prettier\";\n    const importName = getDefaultImportName(importClause);\n    output = {\n      ...output,\n      imports: [\n        ...output.imports,\n        {\n          type: \"default\",\n          packageName,\n          defaultImport: importName,\n        },\n      ],\n    };\n  }\n\n  return output;\n};\n\nconst getDefaultImportName = (importClause: ImportClause): string => {\n  const defaultImport = importClause.getChildrenOfKind(\n    SyntaxKind.Identifier\n  )[0];\n\n  return defaultImport.getText();\n};\n\nconst getNamedImports = (importClause: ImportClause): string[] => {\n  const namedImports = importClause.getChildrenOfKind(\n    SyntaxKind.NamedImports\n  )[0];\n  const syntaxList = namedImports.getChildrenOfKind(SyntaxKind.SyntaxList)[0];\n  const importSpecifiers = syntaxList.getChildrenOfKind(\n    SyntaxKind.ImportSpecifier\n  );\n\n  return importSpecifiers.map((importSpecifier) =>\n    importSpecifier.getChildrenOfKind(SyntaxKind.Identifier)[0].getText()\n  );\n};\n\nconst getNamespaceImport = (importClause: ImportClause): string => {\n  const namespaceImport = importClause.getChildrenOfKind(\n    SyntaxKind.NamespaceImport\n  )[0];\n\n  return namespaceImport.getChildrenOfKind(SyntaxKind.Identifier)[0].getText();\n};\n","import { Node, SyntaxKind } from \"ts-morph\";\n\nimport { ParsePayload } from \"../types/parse-payload\";\n\nexport const handlePropertyAccessExpression = (\n  node: Node,\n  parsePayload: ParsePayload\n): ParsePayload => {\n  const [object, property] = node.getChildrenOfKind(SyntaxKind.Identifier);\n\n  if (property === undefined) {\n    return parsePayload;\n  }\n\n  return {\n    ...parsePayload,\n    propertyAccess: {\n      ...parsePayload.propertyAccess,\n      [object.getText()]: new Set<string>([\n        ...(parsePayload.propertyAccess[object.getText()] ?? []),\n        property.getText(),\n      ]),\n    },\n  };\n};\n","import { Node, SyntaxKind } from \"ts-morph\";\n\nimport { ParsePayload } from \"../types/parse-payload\";\n\nexport const handleVariableStatement = (\n  node: Node,\n  parsePayload: ParsePayload\n): ParsePayload => {\n  const [e] =\n    node\n      .getChildrenOfKind(SyntaxKind.SyntaxList)[0]\n      ?.getChildrenOfKind(SyntaxKind.ExportKeyword) ?? [];\n\n  if (!e || e.getText() !== \"export\") {\n    return parsePayload;\n  }\n\n  const list = node\n    .getFirstChildByKindOrThrow(SyntaxKind.VariableDeclarationList)\n    .getFirstChildByKindOrThrow(SyntaxKind.SyntaxList)\n    .getChildrenOfKind(SyntaxKind.VariableDeclaration)\n    .map((c) => c.getFirstChildByKindOrThrow(SyntaxKind.Identifier))\n    .map((c) => c.getText());\n\n  return {\n    ...parsePayload,\n    exports: [...parsePayload.exports, ...list],\n  };\n};\n","import { Node, SyntaxKind } from \"ts-morph\";\r\n\r\nimport { ParsePayload } from \"../types/parse-payload\";\r\n\r\nexport const handleExportSpecifier = (\r\n  node: Node,\r\n  parsePayload: ParsePayload\r\n): ParsePayload => {\r\n  const identifiers = node.getChildrenOfKind(SyntaxKind.Identifier);\r\n\r\n  if (identifiers.length === 0) {\r\n    return parsePayload;\r\n  }\r\n\r\n  const lastIdentifier = identifiers[identifiers.length - 1];\r\n\r\n  return {\r\n    ...parsePayload,\r\n    exports: [...parsePayload.exports, lastIdentifier.getText()],\r\n  };\r\n};\r\n","import { SyntaxKind, Node } from \"ts-morph\";\r\nimport { ParsePayload } from \"./types/parse-payload\";\r\nimport { handleImport } from \"./handlers/handle-import\";\r\nimport { handlePropertyAccessExpression } from \"./handlers/handle-property-access-expression\";\r\nimport { handleVariableStatement } from \"./handlers/handle-variable-statement\";\r\nimport { handleExportSpecifier } from \"./handlers/export-specifier\";\r\n\r\n// import {\r\n//   handleAccessModifier,\r\n//   handleAny,\r\n//   handleBlock,\r\n//   handleBooleanKeyword,\r\n//   handleCallExpression,\r\n//   handleClass,\r\n//   handleConstructor,\r\n//   handleExpressionStatement,\r\n//   handleIdentifier,\r\n//   handleLiterals,\r\n//   handleStringLiterals,\r\n//   handleParameter,\r\n//   handlePropertyAccessExpression,\r\n//   handlePropertyDeclaration,\r\n//   handleStringKeyword,\r\n//   handleSyntaxList,\r\n//   handleVariableStatement,\r\n//   handleVariableDeclarationList,\r\n//   handleVariableDeclaration,\r\n//   handleNumberKeyword,\r\n//   handleThis,\r\n//   handleEqualsToken,\r\n//   handleMethodDeclaration,\r\n//   handleNewKeyword,\r\n//   handleNewExpression,\r\n//   handleArrayLiteralExpression,\r\n// } from \"@components\";\r\n\r\nexport const traverse = (\r\n  node: Node,\r\n  parsePayload: ParsePayload\r\n): ParsePayload => {\r\n  switch (node.getKind()) {\r\n    // case SyntaxKind.ClassDeclaration:\r\n    //   return handleClass(node, traverse);\r\n    // case SyntaxKind.Constructor:\r\n    //   return handleConstructor(node, traverse);\r\n    // case SyntaxKind.Identifier:\r\n    //   return handleIdentifier(node, traverse);\r\n    // case SyntaxKind.PrivateKeyword:\r\n    // case SyntaxKind.PublicKeyword:\r\n    // case SyntaxKind.StaticKeyword:\r\n    // case SyntaxKind.ProtectedKeyword:\r\n    // case SyntaxKind.ReadonlyKeyword:\r\n    //   return handleAccessModifier(node, traverse);\r\n    // case SyntaxKind.MethodDeclaration:\r\n    //   return handleMethodDeclaration(node);\r\n    // case SyntaxKind.StringLiteral:\r\n    //   return handleStringLiterals(node, traverse);\r\n    // case SyntaxKind.BooleanKeyword:\r\n    //   return handleBooleanKeyword(node, traverse);\r\n    // case SyntaxKind.StringKeyword:\r\n    //   return handleStringKeyword(node);\r\n    // case SyntaxKind.ArrowFunction:\r\n    //   // console.log(\"ArrowFunction\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.AnyKeyword:\r\n    //   return handleAny(node, traverse);\r\n    // case SyntaxKind.Block:\r\n    //   return handleBlock(node, traverse);\r\n    // case SyntaxKind.ReturnStatement:\r\n    //   // console.log(\"ReturnStatement\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.ExpressionStatement:\r\n    //   return handleExpressionStatement(node, traverse);\r\n    // case SyntaxKind.CallExpression:\r\n    //   return handleCallExpression(node, traverse);\r\n    // case SyntaxKind.SyntaxList:\r\n    //   return handleSyntaxList(node, traverse);\r\n    // case SyntaxKind.BinaryExpression:\r\n    //   // console.log(\"BinaryExpression\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.ObjectLiteralExpression:\r\n    //   // console.log(\"ObjectLiteralExpression\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.PropertyAssignment:\r\n    //   // console.log(\"PropertyAssignment\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.NumericLiteral:\r\n    //   return handleLiterals(node, traverse);\r\n    // case SyntaxKind.PrefixUnaryExpression:\r\n    //   // console.log(\"PrefixUnaryExpression\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.PostfixUnaryExpression:\r\n    //   // console.log(\"PostfixUnaryExpression\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.ParenthesizedExpression:\r\n    //   // console.log(\"ParenthesizedExpression\", node.getText());\r\n    //   break;\r\n    // case SyntaxKind.ArrayLiteralExpression:\r\n    //   return handleArrayLiteralExpression(node);\r\n    // case SyntaxKind.ElementAccessExpression:\r\n    //   // console.log(\"ElementAccessExpression\", node.getText());\r\n    //   break;\r\n    case SyntaxKind.PropertyAccessExpression:\r\n      parsePayload = handlePropertyAccessExpression(node, parsePayload);\r\n      break;\r\n    // case SyntaxKind.CommaToken:\r\n    //   return handleIdentifier(node, traverse);\r\n    // case SyntaxKind.Parameter:\r\n    //   return handleParameter(node, traverse);\r\n    // case SyntaxKind.PropertyDeclaration:\r\n    //   return handlePropertyDeclaration(node);\r\n    case SyntaxKind.VariableStatement:\r\n      parsePayload = handleVariableStatement(node, parsePayload);\r\n      break;\r\n    // case SyntaxKind.VariableDeclarationList:\r\n    //   return handleVariableDeclarationList(node);\r\n    // case SyntaxKind.VariableDeclaration:\r\n    //   return handleVariableDeclaration(node);\r\n    // case SyntaxKind.NumberKeyword:\r\n    //   return handleNumberKeyword(node);\r\n    // case SyntaxKind.ThisKeyword:\r\n    //   return handleThis(node);\r\n    // case SyntaxKind.EqualsToken:\r\n    //   return handleEqualsToken(node);\r\n    // case SyntaxKind.NewKeyword:\r\n    //   return handleNewKeyword(node);\r\n    // case SyntaxKind.NewExpression:\r\n    //   return handleNewExpression(node);\r\n    case SyntaxKind.ImportDeclaration:\r\n      parsePayload = handleImport(node, parsePayload);\r\n      break;\r\n    case SyntaxKind.ExportSpecifier:\r\n      parsePayload = handleExportSpecifier(node, parsePayload);\r\n      break;\r\n  }\r\n  //   console.log(node.getKindName());\r\n  //   if (node.getChildCount() === 0) {\r\n  //     console.log(node.getText());\r\n  //   }\r\n  //   console.log(node.getKindName());\r\n  for (const child of node.getChildren()) {\r\n    parsePayload = traverse(child, parsePayload);\r\n  }\r\n\r\n  return parsePayload;\r\n};\r\n","import { AggregateImport, ParsedImport } from \"./ast/types/parse-payload\";\n\nexport const aggregateImports = (\n  imports: ParsedImport[]\n): AggregateImport[] => {\n  // We can not have the same import twice\n\n  const uniqueImports = imports.reduce(\n    (acc: AggregateImport[], curr: ParsedImport) => {\n      const existingImport = acc.find(\n        (i) => i.packageName === curr.packageName\n      );\n\n      const aggregateImport: AggregateImport = {\n        packageName: curr.packageName,\n        defaultImports: [\n          ...(existingImport ? existingImport.defaultImports : []),\n          ...(curr.type === \"default\" ||\n          curr.type === \"default-and-named\" ||\n          curr.type === \"default-and-namespace\"\n            ? [curr.defaultImport]\n            : []),\n        ],\n        namespaceImports: [\n          ...(existingImport ? existingImport.namespaceImports : []),\n          ...(curr.type === \"namespace\" || curr.type === \"default-and-namespace\"\n            ? [curr.namespaceImport]\n            : []),\n        ],\n        namedImports: [\n          ...(existingImport ? existingImport.namedImports : []),\n          ...(curr.type === \"named\" || curr.type === \"default-and-named\"\n            ? [...curr.namedImports]\n            : []),\n        ],\n      };\n\n      return [\n        ...acc.filter((i) => i.packageName !== curr.packageName),\n        aggregateImport,\n      ];\n    },\n    [] as AggregateImport[]\n  );\n\n  return uniqueImports;\n};\n","import path from \"path\";\r\nimport { Project, ScriptTarget } from \"ts-morph\";\r\nimport { traverse } from \"./ast/router\";\r\nimport { DeDupedParsePayload } from \"./create-vitest-ast\";\r\nimport { aggregateImports } from \"./import-aggregator\";\r\n\r\nexport const getFileProperties = (\r\n  specFilePath: string,\r\n  content: string,\r\n  originalFilePath: string\r\n): Omit<DeDupedParsePayload, \"localMocks\"> => {\r\n  const project = new Project({\r\n    compilerOptions: {\r\n      target: ScriptTarget.ESNext,\r\n    },\r\n  });\r\n  const sourceFile = project.createSourceFile(specFilePath, content);\r\n\r\n  const payload = traverse(sourceFile, {\r\n    imports: [],\r\n    propertyAccess: {},\r\n    exports: [],\r\n  });\r\n\r\n  const deDupedPayload: Omit<DeDupedParsePayload, \"localMocks\"> = {\r\n    ...payload,\r\n    fileName: path.basename(originalFilePath),\r\n    imports: aggregateImports(payload.imports),\r\n  };\r\n\r\n  return deDupedPayload;\r\n};\r\n","import { QuestionCollection } from \"inquirer\";\r\n\r\nimport { DeDupedParsePayload } from \"./core/create-vitest-ast\";\r\nimport { AggregateImport } from \"./core/ast/types/parse-payload\";\r\n\r\nexport const createPackageQuestions = ({\r\n  imports,\r\n  propertyAccess,\r\n}: Omit<DeDupedParsePayload, \"localMocks\">): QuestionCollection[] => {\r\n  return imports\r\n    .map((importStatement, i) => {\r\n      const globalMockQuestion: QuestionCollection = {\r\n        type: \"confirm\",\r\n        name: i.toString(), // index hack because inquirer doesn't support file path as name\r\n        message: `Do you want to mock \"${importStatement.packageName}\"? (If this package only has types, you can skip this)`,\r\n        default: true,\r\n      };\r\n\r\n      const localMockQuestion: QuestionCollection = {\r\n        type: \"confirm\",\r\n        name: `${i.toString()}-local`,\r\n        message: `Do you want to mock \"${importStatement.packageName}\" locally for each test? (so you can modify it per test)`,\r\n        default: false,\r\n        when: (answers) => answers[i.toString()] === true,\r\n      };\r\n\r\n      const namedImportQuestions = importStatement.namedImports.map(\r\n        (namedImport) =>\r\n          ({\r\n            type: \"confirm\",\r\n            name: `${i.toString()}-named_import:${namedImport}`,\r\n            message: `Do you want to locally mock \"${namedImport}\" from \"${importStatement.packageName}\"? (You can only mock functions. If this is not a function. Do not mock it!)`,\r\n            default: true,\r\n            when: (answers) => answers[`${i.toString()}-local`] === true,\r\n          }) as QuestionCollection\r\n      );\r\n\r\n      const propertiesOfImport = getPropertyAccessFromImport(\r\n        importStatement,\r\n        propertyAccess\r\n      );\r\n\r\n      const propertyQuestions = propertiesOfImport\r\n        .filter(\r\n          (property) =>\r\n            !isPropertyFromDefaultImport(\r\n              property,\r\n              importStatement,\r\n              propertyAccess\r\n            )\r\n        )\r\n        .map(\r\n          (property) =>\r\n            ({\r\n              type: \"confirm\",\r\n              name: `${i.toString()}-property:${property}`,\r\n              message: `Do you want to locally mock \"${property}\" from \"${importStatement.packageName}\"? (You can only mock functions. If this is not a function. Do not mock it!)`,\r\n              default: true,\r\n              when: (answers) => answers[`${i.toString()}-local`] === true,\r\n            }) as QuestionCollection\r\n        );\r\n\r\n      const defaultPropertyQuestion = propertiesOfImport\r\n        .filter((property) =>\r\n          isPropertyFromDefaultImport(property, importStatement, propertyAccess)\r\n        )\r\n        .map(\r\n          (property) =>\r\n            ({\r\n              type: \"confirm\",\r\n              name: `${i.toString()}-default_property:${property}`,\r\n              message: `Do you want to locally mock \"${property}\" from the default import \"${importStatement.packageName}\"? (You can only mock functions. If this is not a function. Do not mock it!)`,\r\n              default: true,\r\n              when: (answers) => answers[`${i.toString()}-local`] === true,\r\n            }) as QuestionCollection\r\n        );\r\n\r\n      return [\r\n        globalMockQuestion,\r\n        localMockQuestion,\r\n        ...namedImportQuestions,\r\n        ...propertyQuestions,\r\n        ...defaultPropertyQuestion,\r\n      ];\r\n    })\r\n    .flat();\r\n};\r\n\r\nconst isPropertyFromDefaultImport = (\r\n  property: string,\r\n  importStatement: AggregateImport,\r\n  propertyAccess: Record<string, Set<string>>\r\n): boolean => {\r\n  const defaultImport: string | undefined =\r\n    importStatement.defaultImports.filter(\r\n      (d) => d === importStatement.packageName\r\n    )[0];\r\n\r\n  if (!defaultImport) {\r\n    return false;\r\n  }\r\n\r\n  return propertyAccess[defaultImport]?.has(property);\r\n};\r\n\r\nconst getPropertyAccessFromImport = (\r\n  importStatement: AggregateImport,\r\n  propertyAccess: Record<string, Set<string>>\r\n): string[] => {\r\n  const defaultImports = importStatement.defaultImports\r\n    .map((d) => Array.from(propertyAccess[d]))\r\n    .flat();\r\n  const namespaceImports = importStatement.namespaceImports\r\n    .map((d) => Array.from(propertyAccess[d]))\r\n    .flat();\r\n\r\n  return [...defaultImports, ...namespaceImports];\r\n};\r\n","import path from \"path\";\r\nimport fs from \"fs\";\r\n\r\nexport const createFileDetails = (\r\n  fileName: string\r\n): {\r\n  readonly filePath: string;\r\n  readonly fileNameWithoutExtension: string;\r\n  readonly fileExtension: string;\r\n} => {\r\n  const filePath = path.join(process.cwd(), fileName);\r\n  const fileNameWithoutExtension = path.parse(filePath).name;\r\n  const fileExtension = path.extname(filePath);\r\n\r\n  return {\r\n    filePath,\r\n    fileNameWithoutExtension,\r\n    fileExtension,\r\n  };\r\n};\r\n\r\nexport const getNewFileName = (fileName: string, suffix: string) => {\r\n  const { fileNameWithoutExtension, fileExtension } =\r\n    createFileDetails(fileName);\r\n  return `${fileNameWithoutExtension}.${suffix}${fileExtension}`;\r\n};\r\n\r\nexport const removePathPrefixFromCwd = (filePath: string) => {\r\n  return path.dirname(filePath).replace(process.cwd(), \"\");\r\n};\r\n\r\nexport const checkIfTestFileExists = (fileName: string): boolean => {\r\n  const prefix = path.dirname(fileName).replace(process.cwd(), \"\");\r\n  return (\r\n    fs.existsSync(\r\n      path.join(process.cwd(), prefix, getNewFileName(fileName, \"spec\"))\r\n    ) ||\r\n    fs.existsSync(\r\n      path.join(process.cwd(), prefix, getNewFileName(fileName, \"test\"))\r\n    )\r\n  );\r\n};\r\n","// #!/usr/bin/env\r\nimport yargs from \"yargs\";\r\nimport { hideBin } from \"yargs/helpers\";\r\nimport path from \"path\";\r\nimport { createTest } from \"./core/create-test\";\r\nimport fs from \"fs\";\r\nimport inquirer, { InputQuestion, QuestionCollection } from \"inquirer\";\r\nimport chalk from \"chalk\";\r\nimport latestVersion from \"latest-version\";\r\nimport { version } from \"../package.json\" assert { type: \"json\" };\r\n\r\nimport { getFileProperties } from \"./core/get-file-properties\";\r\nimport { InitialAnswers, ModuleMockAnswers } from \"./types\";\r\nimport { createPackageQuestions } from \"./create-package-questions\";\r\nimport {\r\n  checkIfTestFileExists,\r\n  createFileDetails,\r\n  getNewFileName,\r\n  removePathPrefixFromCwd,\r\n} from \"./path-utils\";\r\nimport { SpyOnMockConfig } from \"./core/create-vitest-ast\";\r\n\r\nconsole.log(\r\n  chalk.bgBlueBright.black.bold(\"                                      \")\r\n);\r\nconsole.log(\r\n  chalk.bgBlueBright.black.bold(\"   ðŸ§ª Welcome to create vitest! ðŸ—ï¸     \")\r\n);\r\nconsole.log(chalk.bgBlueBright.black(\"                      by Dolan        \"));\r\n\r\nconsole.log(\"\");\r\nconsole.log(\r\n  chalk.green(\r\n    \"Generate a vitest test (spec) file for a TypeScript file with best practices. Scaffold the test and mock all imports\"\r\n  )\r\n);\r\nconsole.log(\r\n  chalk.blue(\r\n    `â„¹ï¸ Note: Every so often, run \"npm create vitest@latest\" or \"npx create-vitest@latest\" to update to the latest version. ðŸ† `\r\n  )\r\n);\r\ntry {\r\n  console.log(\r\n    chalk.blue(\r\n      `â„¹ï¸ Current version: ${version}. Latest version: ${await latestVersion(\r\n        \"create-vitest\"\r\n      )}.`\r\n    )\r\n  );\r\n} catch {}\r\nconsole.log(\"\");\r\nconsole.log(\r\n  chalk.bgWhite.bold(\"GitHub: https://github.com/dolanmiu/create-vitest\")\r\n);\r\nconsole.log(\"\");\r\n\r\nconst {\r\n  _: [fileName],\r\n} = yargs(hideBin(process.argv)).argv as any;\r\n\r\nif (fileName) {\r\n  if (!/^[a-zA-Z0-9-_/\\\\]+\\.tsx?$/.test(fileName)) {\r\n    console.log(chalk.red(\"The file name must end in .ts or .tsx\"));\r\n    process.exit(1);\r\n  }\r\n\r\n  if (!fs.existsSync(path.join(process.cwd(), fileName))) {\r\n    console.log(chalk.red(\"The file does not exist!\"));\r\n    process.exit(1);\r\n  }\r\n\r\n  if (checkIfTestFileExists(fileName)) {\r\n    console.log(\r\n      chalk.red(\r\n        \"A test file already exists for this file! Please delete the existing test file and try again.\"\r\n      )\r\n    );\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nconst questions: QuestionCollection[] = [\r\n  ...(fileName\r\n    ? []\r\n    : [\r\n        {\r\n          type: \"input\",\r\n          name: \"fileName\",\r\n          message:\r\n            \"What is the name of the file you want to test? (Relative to current directory)\",\r\n          validate: async (input) => {\r\n            if (input === \"\") {\r\n              return \"You must specify a file name!\";\r\n            }\r\n\r\n            if (!/^[.a-zA-Z0-9-_/\\\\]+\\.tsx?$/.test(input)) {\r\n              return \"The file name must end in .ts or .tsx\";\r\n            }\r\n\r\n            if (!fs.existsSync(path.join(process.cwd(), input))) {\r\n              return \"The file does not exist!\";\r\n            }\r\n\r\n            if (checkIfTestFileExists(input)) {\r\n              return \"A test file already exists for this file!\";\r\n            }\r\n\r\n            return true;\r\n          },\r\n        } as InputQuestion,\r\n      ]),\r\n  {\r\n    type: \"list\",\r\n    name: \"suffix\",\r\n    message: \"What suffix would you like the test to end in?\",\r\n    choices: [\"spec\", \"test\"],\r\n  },\r\n  {\r\n    type: \"confirm\",\r\n    name: \"confirm\",\r\n    message: (a) =>\r\n      `The path of the file is \"${\r\n        createFileDetails(fileName ?? a.fileName).filePath\r\n      }\". Is this correct?`,\r\n  },\r\n];\r\n\r\nconst askQuestions = async () => {\r\n  const answers = await inquirer.prompt<InitialAnswers>(questions);\r\n\r\n  if (!fileName && !answers.fileName) {\r\n    console.log(chalk.red(\"You must specify a file name!\"));\r\n    process.exit(1);\r\n  }\r\n\r\n  const { filePath } = createFileDetails(fileName ?? answers.fileName);\r\n  const newFileName = getNewFileName(\r\n    fileName ?? answers.fileName,\r\n    answers.suffix\r\n  );\r\n\r\n  const fileContent = fs.readFileSync(filePath, \"utf-8\");\r\n  const filePayload = getFileProperties(\r\n    newFileName,\r\n    fileContent,\r\n    fileName ?? answers.fileName\r\n  );\r\n\r\n  const moduleQuestions = createPackageQuestions(filePayload);\r\n  const moduleAnswers =\r\n    await inquirer.prompt<Record<string, boolean>>(moduleQuestions);\r\n\r\n  const trueModuleAnswers = Object.entries(moduleAnswers)\r\n    .map(([key, value]) => {\r\n      // key can be \"0\" or \"0-local\" or \"0-named_import:describe\" or \"0-property:key\"\r\n      // get the index\r\n      const index = parseInt(key.split(\"-\")[0]);\r\n      const myImport = filePayload.imports[index];\r\n\r\n      // get the named_import or property\r\n      const [, namedImport] = key.split(\"-named_import:\");\r\n      const [, property] = key.split(\"-property:\");\r\n      const [, defaultProperty] = key.split(\"-default_property:\");\r\n      return {\r\n        packageName: myImport.packageName,\r\n        value,\r\n        type: !!(namedImport ?? property) ? \"named_import\" : !!defaultProperty ? \"default\" : \"root\",\r\n        property: (namedImport ?? property ?? defaultProperty) as string | undefined,\r\n      } as ModuleMockAnswers;\r\n    })\r\n    .filter(({ value }) => !!value);\r\n\r\n  const includePackages = new Set(\r\n    trueModuleAnswers.map(({ packageName }) => packageName)\r\n  );\r\n\r\n  const namedImportMocks: SpyOnMockConfig[] = trueModuleAnswers\r\n    .filter(({ property }) => !!property)\r\n    .filter(({ type }) => type === \"named_import\")\r\n    .map((o) => o as SpyOnMockConfig);\r\n\r\n  const defaultMocks: SpyOnMockConfig[] = trueModuleAnswers\r\n    .filter(({ property }) => !!property)\r\n    .filter(({ type }) => type === \"default\")\r\n    .map((o) => o as SpyOnMockConfig);\r\n\r\n  console.log(chalk.green(`Generating ${newFileName}...`));\r\n\r\n  const content = await createTest({\r\n    ...filePayload,\r\n    imports: filePayload.imports.filter((i) =>\r\n      includePackages.has(i.packageName)\r\n    ),\r\n    localMocks: {\r\n      namedImportMocks,\r\n      defaultMocks,\r\n    },\r\n  });\r\n\r\n  fs.promises.writeFile(\r\n    path.join(process.cwd(), removePathPrefixFromCwd(filePath), newFileName),\r\n    content\r\n  );\r\n};\r\n\r\naskQuestions();\r\n"],"names":["createVitestAst","payload","testSourceFile","Project","StructureKind","i","createMockObject","e","createSpyOnNamedImportMockObject","createSpyOnDefaultMockObject","propertyAccess","createImportObject","acc","curr","imports","spyOnConfig","createTest","output","prettier","handleImport","node","parsePayload","packageName","SyntaxKind","importClause","defaultImport","getDefaultImportName","namedImports","getNamedImports","namespaceImport","getNamespaceImport","importName","importSpecifier","handlePropertyAccessExpression","object","property","handleVariableStatement","list","c","handleExportSpecifier","identifiers","lastIdentifier","traverse","child","aggregateImports","existingImport","aggregateImport","getFileProperties","specFilePath","content","originalFilePath","sourceFile","ScriptTarget","path","createPackageQuestions","importStatement","globalMockQuestion","localMockQuestion","answers","namedImportQuestions","namedImport","propertiesOfImport","getPropertyAccessFromImport","propertyQuestions","isPropertyFromDefaultImport","defaultPropertyQuestion","d","defaultImports","namespaceImports","createFileDetails","fileName","filePath","fileNameWithoutExtension","fileExtension","getNewFileName","suffix","removePathPrefixFromCwd","checkIfTestFileExists","prefix","fs","chalk","version","latestVersion","yargs","hideBin","questions","input","a","askQuestions","inquirer","newFileName","fileContent","filePayload","moduleQuestions","moduleAnswers","trueModuleAnswers","key","value","index","myImport","defaultProperty","includePackages","namedImportMocks","type","o","defaultMocks"],"mappings":"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"}